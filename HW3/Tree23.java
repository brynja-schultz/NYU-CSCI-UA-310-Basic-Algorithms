//Tree23.java (partially implemented)
/*****************************************
  	Overview: implementation of 2-3 trees
		Tree23 is our main class:
			but it depends on two classes:
		   		InternalNode class
				LeafNode class
			which are both extensions of the Node class.

		In this file, there are 4 methods you need to implement:
				find, search, insert, delete.
			To find them in this file, search for this line of text:
				// IMPLEMENT ME HERE:%%%%%%%%%%%%%%
				
	MEMBERS of Tree23: ====================================
		Item class:
				String key;
				int data;
		Node class:
				Node parent;
				String guide;
		InternalNode class:
				Node[] child[4];	//THIS ALLOWS YOU TO WRITE LOOPS
				//If degree is d, then non-null children are child[0..d-1]
		LeafNode class:
				int data;
		Tree23 class:
				InternalNode root;
				int height;
	METHODS of Tree23: ====================================
		Tree23 class:
				Item search(String);
				boolean insert(Item);
				Item delete(String);
			All these 3 methods call the helper method,
				InternalNode find(String); // returns a pseudo-leaf
			We provide you with various debugging tools.  E.g.,
				showTree() -- prints a representation of the tree
				dbug(String)
				debug(String)
	Terminology:
		An InternalNode whose children are LeafNodes is
			called a "pseudo-leaf"
	Design Decision:
		1. The root is always a InternalNode, never null. 
		2. Normally, an InternalNode has degrees 2 or 3.
			But the root is allowed to have degrees 0 or 1.
			Also, temporarily, InternalNodes may have degrees
			1 (during deletion) or 4 (during insertion).
		3. We decide to have ht (height) as members, as it simplifies
			our algorithms (it is possible NOT to remember ht).
		4. Most methods are naturally put into one of 2 classes:
				(a) InternalNode class or
				(b) Tree23 class:
		(a) Contains methods that are "per node" (sometimes involving
				parent or child) belongs to (a).
				E.g., degree(), sortNode()
		(b)	Contains methods that involve arbitrarily many levels
				belongs to (b).
				E.g., search/insert/delete, showTree(), checkTree()
		5. We decide to use Strings for keys in our items.
			To randomly generate such keys, we can use
			the Zoombine class as follows:
					Random rg = new Random(seed);
					Zoombini zoom = new Zoombini(rg);
					Item it = new Item(zoom.name());
				 		//it.data can be automatically generated by Item
		6. Main Method in Tree23:
				We use the usual ss (seed), nn (problem size), mm (mode).
				Modes indicate the various tests:
					e.g., mm=0 calls the unitTest.
				Modes mm from 0 to 99 is reserved for our use.
				You can create modes mm larger than 99 for your use.
	====================================
	Author: Chee Yap, Basic Algorithms
 **************************************** */
import java.util.Random;

class Tree23 extends Util {
	// STATIC MEMBERS:==================================
		static Random rg;
		static Zoombini zoom;
	// MEMBERS:=========================================
	/////////////////////////////////////////
		InternalNode root = new InternalNode();
		int ht = 0;	//	ht=0 iff root.degree() = 0
					//  ht=1 iff root.degree() > 1
	// CONSTRUCTORS:====================================
	/////////////////////////////////////////
		Tree23 (Random rgen){
			rg = rgen;
			zoom = new Zoombini(rg); 
		}
		Tree23 () {
			rg = new Random();
			zoom = new Zoombini(rg); 
		}
	// METHODS:=========================================
	/////////////////////////////////////////
	InternalNode find (String x){
		// find(x) returns the Internal Node u such that either contains x
		//		or where x would be inserted.  Thus u is a pseudo-leaf.
		//		The node u is NEVER null.
		// 	This is the common helper for search/insert/delete!!
		if (ht <= 1) return root;
		InternalNode u = root;
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// IMPLEMENT ME HERE:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		//FINDS INTERNAL NODE
		while(u.child[0] instanceof InternalNode){ // traverse tree up until internal nodes above leaves
			if(u.degree() == 3 && (u.child[1].guide.compareTo(x) < 0)) u = (InternalNode) u.child[2]; // 3rd child exists and child's key < x
			else if(u.child[0].guide.compareTo(x) >= 0) u = (InternalNode) u.child[0];
			else u = (InternalNode) u.child[1];
		}
		return u;
		}//find
	LeafNode search (String x){
		// Returns a null node if failure;
		// 		otherwise, return a LeafNode with the key x.
		InternalNode u = find(x); // never null
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// IMPLEMENT ME HERE:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		//FINDS LEAF NODE
		for(int i=0; i<u.degree(); i++){
			if(u.child[i].guide.compareTo(x) == 0) return (LeafNode) u.child[i];
		}
		return null; // x is not found
		}
	boolean insert (Item it){
		// insert(it) returns true iff insertion is successful.
		if (ht==0) { // only once!
			ht=1;
			root.addLeaf(it); return true; } 
		InternalNode u = find(it.key); // never null
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%m%%%%%%
		// IMPLEMENT ME HERE:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		int d = u.addLeaf(it);
		u.sortNode();

		if(d == 0) return false; // inserting duplicate
	
		if (u.degree()==4){
			split(u);
		}
		while(u.parent != null && u.parent.guide.compareTo(u.guide) < 0){
			u.parent.guide = u.guide;
			u = u.parent;
		}
		return true;
	}//insert
	boolean split(InternalNode u){	
		if(u.parent != null){ // u was not the root 
			InternalNode parent = u.parent;
			int u_index = parent.getIndexOf(u); 

			InternalNode sibling = new InternalNode();
			sibling.guide = u.child[1].guide;
			sibling.parent = parent; 
			sibling.child[0] = u.child[0];
			sibling.child[0].parent = sibling;
			sibling.child[1] = u.child[1];
			sibling.child[1].parent = sibling;

			u.child[0] = u.child[2];
			u.child[1] = u.child[3];
			u.child[2] = null;
			u.child[3] = null;
				
			for(int i = parent.degree() - 1; i >= u_index; i--){
				parent.child[i+1] = parent.child[i];
			}
			parent.child[u_index] = sibling; 
			parent.sortNode();
			if(parent.degree() == 4) split(parent);
		}//internal if statement

		else{ // u was the root 
			InternalNode parent = new InternalNode();

			parent.guide = u.guide; 
			parent.parent = null;

			InternalNode left_subtree = new InternalNode();
			left_subtree.guide = u.child[1].guide;
			left_subtree.parent = parent;

			left_subtree.child[0] = u.child[0];
			left_subtree.child[0].parent = left_subtree;
			left_subtree.child[1] = u.child[1];
			left_subtree.child[1].parent = left_subtree;
			
			u.child[0] = u.child[2];
			u.child[1] = u.child[3];
			u.child[2] = null;
			u.child[3] = null;
			u.parent = parent; 

			parent.child[0] = left_subtree;
			parent.child[1] = u;

			root = parent;
			ht++;

		}//internal else statment 	
		return true; 
	}

//NEED TO COMPLETE DELETE METHOD!!!!!
	Item delete (String x){
		// delete(x) returns the deleted item
		//			returns null if nothing is deleted.
		InternalNode u = find(x); // never null
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// IMPLEMENT ME HERE:%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		
		LeafNode deleted = search(x); // finds leaf node that is meant to be deleted 
		if(deleted == null) return null;
		int deleted_index = 0;
		for(int i=0; i<u.degree(); i++){ //finds index of leaf node to be deleted in relation to u
			if(u.child[i].guide.compareTo(x) ==0) deleted_index = i;
		}		
		Item deleted_leaf = u.removeLeaf(x);
		if(deleted_leaf == null) return null; //deletion failed
		if (u.degree()>0) u.guide = u.child[u.degree()-1].guide; // not a leaf node
		boolean not_finished = true;
		while(u.degree() == 1 && u.parent != null){ // runs for internal node with only 1 child
			InternalNode parent = u.parent;
			int u_index = parent.getIndexOf(u); // u's index in relation to its parent
			if(u_index == 0 && parent.child[1] != null){ // if there's a right child 
				not_finished = parent.proposeRight(u_index); //runs if u is 1st node & second child exists //*******ERROR OCCURS HERE*******
			}
			else{
				not_finished = parent.proposeLeft(u_index); // true if merge, false if adopt
			}
			u = parent; 	
		}
		if (root.degree() == 1){ // get rid of root 
			if(root.child[0] instanceof LeafNode){
				root.child[0] = null;
				ht--;
			}
			else{
				root = (InternalNode) root.child[0];
				root.parent = null;
				ht--;
			}
		}
		return deleted_leaf;
	}//delete



	// HELPERS:=========================================
	/////////////////////////////////////////
	Tree23 multiInsert (int n, int N){
		// Insert n times into empty tree, and return the tree.
		// The inserted keys are all "numeric strings" (!!).
		// Use rg as random number generator keys in range [0,N)
		// Store the size of tree in Util.COUNT
		//	    NOTE: multiInsert(..) is similar to randomTree(..)
		Tree23 t = new Tree23(rg);
		COUNT=0; // this is Util.COUNT.
		int perline=4; // number of insertions per line
		for (int i=0; i<n; i++){
			Item it = new Item(rg.nextInt(N));
			boolean b=t.insert(it);
			if (b) COUNT++;
			dbug("ins(" + it.key + ")="+ String.valueOf(b)+" ");
			if (perline==0) {
				perline=4; dbug("\n");
			} else perline--;
		}//for
		return t; }//multiInsert
	void multiDelete (Random rg, int nn){
		// This is the converse of "multiInsert(..), where
		// we randomly delete keys from a Tree23 formed by
		// multiInsert(..)
		//	    NOTE: multiDelete(..) is similar to randomDelete(..)
		debug("==> Begin multiDelete");
			Tree23 tt = new Tree23(rg);
			tt =tt.multiInsert(nn, 2*nn);
			assert(tt!=null);
		debug("Random tree of size "+String.valueOf(Util.COUNT)
						+" is:");
			tt.showTree();
			int tries=0; int size=0;
			while (tries<4*nn && tt.ht>0){
				Item it=tt.delete(String.valueOf(rg.nextInt(2*nn)));
				if (it!=null) { // something was deleted
					size++; debug("  ====> multiDeleted key="+it.key);
					}
				tries++; }//while
			debug("Number of deleted keys is " + String.valueOf(size));
			if (tries==100)
				debug("Tree non-empty after 100 random deletes");
			else
				debug("After " + String.valueOf(tries)
						+ " attempted deletions, tree is empty"); 
	}//multiDelete
	Tree23 randomTree (int n, int N) {
		// Insert n times into empty tree, and return the tree.
		// Use rg as random number generator keys in range [0,N)
		// Keep the size of tree in Util.COUNT
		//	    NOTE: multiInsert(..) is similar to randomTree(..)
		Tree23 t = new Tree23(rg);
		COUNT=0;
		for (int i = 0; i < n; i++) {
			int x = rg.nextInt(N);
			Item it = new Item(x);
			boolean b = t.insert(it);
			if (b)  COUNT++;
		} // for
		return t;
	}// randomTree
	Tree23 randomTree (int n) { 
		// Insert n Zoombini names into empty tree, and return the tree.
		// Keep the size of tree in Util.COUNT
		// This is a variant of "randomTree(n,N)"
		Tree23 t = new Tree23(rg);
		COUNT=0;  
		for (int i = 0; i < n; i++) {
			Item it = new Item(zoom.name(), rg);
			boolean b = t.insert(it);
			if (b)  COUNT++;
		} // for
		return t; // size of this tree = COUNT.
	}// randomTree(n)
	int randomDelete (Tree23 tt, int N) {
			// delete a random key in the tree N times until empty
			// Use rg as random number generator keys in range [0,N)
			// return the delete count if tree is empty
		int count = 0;
		Item it;
		while (count < N && tt.ht > 0) {
			it = tt.delete(String.valueOf(rg.nextInt(N)));
			count++;
		}
		return count;
		}// randomDelete
	////////////////////////////////////////// UNIT TEST:
	void unitTest (){
		// unitTest() is meant to be a comprehensive test of most of
		// 	our methods: They are "self-validating" in the sense
		//  that it will check if the results are correct (or you can
		//  visually check correctness from the output).
		// First input: //////////////////////////////////////
		debug("\n\n=============== BEGIN UNIT TEST ================");
		debug("\n================================================");
		debug("\n======> Inserting Fruits:");
		String[] fruits =
			{"banana","apple","peach","orange",
				"apple","prune","pear","plum"};
		for (String x: fruits){
			boolean in = insert( new Item(x,rg));
			debug("ins(" + x + ") = " + String.valueOf(in));
		}
		debug("Here is the final Fruit Tree:");
		showTree(); // this is the default tree (fruit tree)
		if (checkTree()==null) debug("\n checktree error!");
		else debug("\n checkTree succeeds!");
		debug("\n======> Inserting sqrt(3) digits:");
		// Second input: /////////////////////////////////////
		// 	Digits of sqrt(3)=1.73205080...;
		int[] input = {1, 7, 3, 2, 0, 5, 0, 8, 0};
		Tree23 t = new Tree23(rg);
		for (int x : input){
			Item it = new Item(x);
			boolean in = t.insert(it);
			debug("ins(" + x + ") = " + String.valueOf(in));
		}
		debug("Here is the final sqrt(3) Tree:");
		t.showTree();
		if (t.checkTree()==null) debug("\n checkTree error!");
		else debug("\n checkTree succeeds!");

		// SEARCHES: //////////////////////////////////////
		debug("\n======> Searching Fruits");
		LeafNode v = search("banana");
		if (v==null) 
			debug("Fruit Tree: search(banana) fails");
		else
			debug("Fruit Tree: search(banana) succeeds");
		v = search("cherry");
		if (v==null) 
			debug("Fruit Tree: search(cherry) fails");
		else
			debug("Fruit Tree: search(cherry) succeeds");

		debug("\n======> Searching Digits");
		v = t.search(String.valueOf(3));
		if (v==null) 
			debug("Sqrt3 Tree: search(3) fails");
		else
			debug("Sqrt3 Tree: search(3) succeeds");
		v = t.search(String.valueOf(4));
		if (v==null) 
			debug("Sqrt3 Tree: search(4) fails");
		else
			debug("Sqrt3 Tree: search(4) succeeds");

		// DELETES: //////////////////////////////////////
		debug("\n=============== deleting fruits");
		delete("peach");
			debug("Fruit Tree after DELETE(peach):");
			showTree(); 
			// This can be affected by the delete policy!
			// E.g., proposeLeft and ProposeRight are different.
		delete("plum");
			debug("Fruit Tree after DELETE(plum):");
			showTree();
		delete("apricot");
			debug("Fruit Tree after DELETE(apricot):");
			showTree();
		delete("apple");
			debug("Fruit Tree after DELETE(apple):");
			showTree();
		debug("\n=============== deleting digits");
		t.delete(String.valueOf(3));
			debug("Sqrt3 Tree after DELETE(3):");
			t.showTree();
		t.delete(String.valueOf(0));
			debug("Sqrt3 Tree after DELETE(0):");
			t.showTree();
		debug("\n=============== END OF UNIT TEST ===============");
		debug("\n================================================\n\n");
		}//unitTest
	static void unit (){
		// Used for ANYTHING for your own experiments!
		Tree23 tt= new Tree23(rg);
		tt.insert(new Item(3));
		tt.insert(new Item(1));
		tt.insert(new Item(4));
		tt.insert(new Item(5));
		Node u = tt.root;
		if (u instanceof InternalNode) debug("root is IntNode");
			else debug("root is NOT IntNode");
		if (u instanceof LeafNode) debug("root is LeafNode");
			else debug("root is NOT LeafNode");

		InternalNode v = (InternalNode)u;
		//  v.child[0]  should be IntNodes:
		if (v.child[0] instanceof InternalNode) debug("u0 is IntNode");
			else debug("u0 is NOT IntNode");
		if (v.child[0] instanceof LeafNode) debug("u0 is LeafNode");
			else debug("u0 is NOT LeafNode");
		// THIS IS CORRECT: u are leaves:
		u = v.child[0];
		if (u instanceof InternalNode) debug("u00 is IntNode");
			else debug("u00 is NOT IntNode");
		if (u instanceof LeafNode) debug("u00 is LeafNode");
			else debug("u00 is NOT LeafNode");
	}//unit
	String checkTree (){ 
		// returns null iff the keys are in NOT in sorted order!
		// CAREFUL:  we do not check the guides
		int h=ht;
		InternalNode u=root; 
		String s=checkTree(u,h,""); // "" is the globally least key!
		// if (s==null) // May NOT be error! let the caller decide.
		//	return "CHECKTREE ERROR";
		return s; }
	String checkTree (Node u, int h, String maxkey){
		// internal recursive call for checkTree
		// returns null if fail; else it is the maximum seen so far!
		if (h==0) return "OK, EMPTY TREE";
		int d=((InternalNode)u).degree();
		for (int i=0; i<d; i++)
			if (h==1){
				Node w = ((InternalNode)u).child[i];
				LeafNode v = (LeafNode)w;
				if (maxkey.compareTo(v.item().key) >=0){ //error!
					debug("CHECKTREE ERROR at leaf "+v.item().key);
					return null;
				} else
					maxkey=v.item().key;
				//debug("   ===> CHECKTREE maxkey = "+maxkey);
			} else {
				String s1=
					checkTree(((InternalNode)u).child[i], h-1, maxkey);
				if(s1==null || maxkey.compareTo(s1) >=0){
					//debug("CHECKTREE ERROR! key "+s1);
					// NOTE: may not be error!  Let caller decide!
					return null;
				} else
					maxkey = s1;
			}
		return maxkey;}//checkTree
	void showTree (){
		// print all the keys in 23tree:
		// NOTE: don't do "ok()" here -- sometimes you want to see
		//	the incorrect tree for debugging or testing.
		int h=ht;
		InternalNode u=root;
		showTree(u,h,"");
		dbug("\n"); }//showTree
	void showTree (Node u, int h, String offset){
		// internal recursive call for showTree
		if (h==0){
			debug("()"); return;}
		int d=((InternalNode)u).degree();
		String increment= "G="+ String.valueOf(u.guide) +":(";
		// Note: "G=" refers to the "guide"
		dbug(increment);
		offset = offset + tab(increment.length()-1,'-') + "|";
		for (int i=0; i<d; i++)
			if (h==1){
				Node w = ((InternalNode)u).child[i];
				LeafNode v = (LeafNode)w;
				(v.item()).dump();
				if (i==d-1) debug(")");
			} else {
				if (i>0) dbug(offset);
				showTree(((InternalNode)u).child[i],h-1,
							offset);
			}
		//dbug(")");
		}//showTree
	void testShowTree(){
		debug("===========TEST SHOW TREE");
		Tree23 tt = new Tree23(rg);
		for (int i=0; i<20; i++){
			tt.insert(new Item(i));
		}
		tt.showTree();
	}
	void messUpTree (String key){
		// swaps the first and last child of a pseudo-leaf 
		// Thus a valid 2-3 tree becomes invalid!
		// (We use it for testing)
		InternalNode u = find(key);
		int deg= u.degree();
		u.swapNodes(0,deg-1);
		}//messUpTree
	void ok (){
		// checks that tree is locally OK (degree&guide checks)
		// WARNING: globally, the tree can still be wrong!
		assert(root != null): "root is null";
		//assert(ht > 0): "ht=0 (WARNING: NOT always assumed)";
		ok(root, ht); } // call recursive ok
	void ok (InternalNode u, int h){
		// recursive ok
		int d=u.degree();
		if (h==1) {
			assert(d>=0 && d<4) : "root.degree is not in [0..4)";
			u.isSorted();
			return; }
		assert(d==2 || d==3) : "non-root degree is not 2 or 3"; 
		u.isSorted();
		for(int i=0; i<d; i++){
			InternalNode v = (InternalNode)(u.child[i]);
			ok(v, h-1); // recursive check
		}//for
		assert(u.guide.compareTo(u.child[d-1].guide) >=0)
			: "parent guide less than child guide";
	}//ok
	// MAIN METHODS:=========================
	/////////////////////////////////////////
	public static void main (String[] args) {
		int ss = (args.length > 0) ? Integer.valueOf(args[0]) : 0;
		int nn = (args.length > 1) ? Integer.valueOf(args[1]) : 10;
		int mm = (args.length > 2) ? Integer.valueOf(args[2]) : 0;
	
		Random rg = (ss == 0) ? new Random() : new Random(ss);
		Tree23 tt = new Tree23(rg);
		int count;
		////I ADDED
		//mm = 2;
		///
		switch (mm) {
			case 0: // unit test for insert+search+delete
				debug("==> mode 0: unit test\n");
				tt.unitTest();
				break;
			case 1: // search for "10" once
				debug("==> mode 1: random insert+search once\n");
				Tree23 ttt = tt.multiInsert(nn, 2*nn);
				debug("This is the resulting tree:\n");
				ttt.showTree();
				LeafNode ln = tt.search("10");
				if (ln==null) debug("10 is not found in tree");
				else {debug("10 is found in tree leaf:"); ln.dump();}
				break;
			case 2: // random insertion and then random deletion:
				debug("==> mode 2: random insert+search till success\n");
				tt=tt.multiInsert(nn,2*nn);
				debug("This is the tree after many insertions: \n");
					tt.showTree();
				debug("Next, we do random deletions from above tree. \n");
				int N = 2*nn;
				count = tt.randomDelete(tt, N);
				if (tt.ht >= 1) {
					debug("Tree non-empty after " + N + " random deletes;"
							+"here is what's left:");
					tt.showTree();
				} else
					debug("After " + String.valueOf(count)
							+ " deletes, tree is empty");
				break;
			case 3: 
				debug("==> mode 8: testing ok() (should abort)\n");
				nn=15;
				tt = tt.randomTree(nn);  // Zoombini names!
				tt.showTree();
				tt.ok();  // THIS SHOULD BE FINE
				tt.messUpTree("10");
				debug("after messUpTree(10) -- it should abort!");
				tt.showTree();
				tt.ok();  // THIS WILL ABORT!
				break;	
			case 101: // create a random tree with nn random insertions
				debug("==> mode 101: create a random tree\n");
				tt = tt.randomTree(nn, 2 * nn);
				debug("Randomly generated tree of is:");
				tt.showTree();
				break;
			case 102: // randomly delete 100 times until it's empty
				debug("==> mode 102:" 
						+ "randomly delete till random tree is empty\n");
				tt = tt.randomTree(nn, 2 * nn);
				debug("Randomly generated tree of is:");
				tt.showTree();
				count = tt.randomDelete(tt, 2 * nn);
				if (tt.ht >= 1) {
					debug("Tree non-empty after 100 random deletes;"
							+"here is what's left:");
					tt.showTree();
				} else
					debug("After " + String.valueOf(count)
							+ " deletes, tree is empty");
				break;
		}//switch
	}// main
}//class Tree23

//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
//%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

